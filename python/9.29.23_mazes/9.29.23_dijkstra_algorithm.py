# changes: 1.run-time. 2.manhattan-distance. 3.instead of giving 8 closest neighbors I gave
# the neighbors with a distance of 3 to each direction. done in: 9.2.23
# left to try to use A function that divides the image into areas of the same color
# and then each area can be treated as a single element and then there are much fewer elements.
# I saw it in GPT

# -*- coding: utf-8 -*-

"""Dijkstra algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kLuQX4yKikjpVOR8X9OAmmiF9pptt5pd
"""

import cv2
import matplotlib.pyplot as plt
import heapq
import time
import numpy as np

start_time = time.time()  # Record the start time

# here are the file path and start/end points.

# file = 'C:\\Users\\User\\Downloads\\mazes\\maze.png'
# start_point = (220, 5)
# end_point = (5, 25)
file = 'C:\\Users\\User\\Downloads\\mazes\\maze5.jpg'
start_point = (320, 5)
end_point = (320, 301)
# file = 'C:\\Users\\User\\Downloads\\mazes\\maze50.jpg'
# start_point = (200, 20)
# end_point = (200, 600)

start_point_circle = start_point[1], start_point[0]
end_point_circle = end_point[1], end_point[0]
img = cv2.imread(file)  # read an image from a file using
cv2.circle(img, start_point_circle, 3, (255, 0, 0), -1)  # add a circle at start_point
cv2.circle(img, end_point_circle, 3, (0, 0, 255), -1)  # add a circle at end_point
# plt.figure(figsize=(7, 7))
# plt.imshow(img)  # show the image
img = cv2.imread(file)
plt.show()

img2 = img.min(axis=2)
# img = img[:,:,0]
binary_img = img2 // 200


def dijkstra_path(img, start: list, end):
    # takes the start point and updating his neighbors (about the cost(= distance from the start))
    # and their neighbors and so on.
    # eventually we'll get the price for the end.
    # the representation of a node: [(x,y), cost, parent]
    # the representation of a node in min_heap: [cost, (x,y), parent]
    cheapest = {}
    min_heap = [start]
    min_heap_dict = {}
    passed_in_heap = []
    while end not in cheapest:

        # take the cheapest
        new_node = heapq.heappop(min_heap)
        if new_node[1] in cheapest:
            continue

        cheapest[new_node[1]] = [new_node[0], new_node[2]]
        passed_in_heap += relax_neighbors(new_node, min_heap, min_heap_dict, cheapest, end)
        if new_node[1][0] > end[0] - 5 and new_node[1][0] < end[0] + 5 and new_node[1][1] > end[1] - 5 and new_node[1][
            1] < end[1] + 5:
            end = new_node[1]
            break

    path = [end]
    node = cheapest[end][1]
    while (start[1]) not in path:
        path.append(node)
        node = cheapest[node][1]
    heap = [element[1] for element in min_heap]

    return path, passed_in_heap


# heap-node/node: [cost, (y,x), parent]
# dict node/neighbor: [(y,x), cost, parent]
def relax_neighbors(node, min_heap, min_heap_dict, cheapest, end):
    passed_in_heap = []
    the_neighbors, all_medium_points = neighbors(node)
    dim = img.shape
    height, width = dim[0] - 4, dim[1] - 4
    # need to init the cost of the neighbors.
    for i in range(len(the_neighbors)):
        neighbor, medium_points = the_neighbors[i], all_medium_points[i]
        manhattan_distance = abs(neighbor[0][0] - end[0]) + abs(neighbor[0][1] - end[1])

        # if they are out of range, or they are black dots - omit them.
        if neighbor[0][0] > height or neighbor[0][0] < 4 or neighbor[0][1] > width \
                or neighbor[0][1] < 4 or binary_img[neighbor[0]] != 1 \
                or binary_img[medium_points[0]] != 1 or binary_img[medium_points[1]] != 1:
            continue

        # if they are already in cheapest - omit.
        if neighbor[0] in cheapest:
            continue

        # if they are already in the heap - their initial cost is as in heap, or cheaper.
        elif neighbor[0] in min_heap_dict:
            if min_heap_dict[neighbor[0]][0] > neighbor[1]:
                heapq.heappush(min_heap,[neighbor[1]+manhattan_distance*10,neighbor[0],neighbor[2]])
                min_heap_dict[neighbor[0]][0] = neighbor[1]
            continue

        # if none of the above: their cost is as the parent + 1
        else:
            heapq.heappush(min_heap, [node[0] + 1 + manhattan_distance, neighbor[0], node[1]])
            min_heap_dict[neighbor[0]] = [node[0] + 1, node[1]]
            passed_in_heap.append(neighbor[0])
    return passed_in_heap


def neighbors(node):
    y, x = node[1]
    cost, parent = node[0] + 1, node[1]
    neighbors = [
        [(y - 3, x - 3), cost, parent],
        [(y - 3, x), cost, parent],
        [(y - 3, x + 3), cost, parent],
        [(y, x - 3), cost, parent],
        [(y, x + 3), cost, parent],
        [(y + 3, x - 3), cost, parent],
        [(y + 3, x), cost, parent],
        [(y + 3, x + 3), cost, parent]
    ]
    medium_points = [
        [(y - 2, x - 2), (y - 1, x - 1)],
        [(y - 1, x), (y - 2, x)],
        [(y - 1, x + 1), (y - 2, x + 2)],
        [(y - 1, x + 1), (y - 2, x + 2)],
        [(y, x + 1), (y, x + 2)],
        [(y + 1, x - 1), (y + 2, x - 2)],
        [(y + 1, x), (y + 2, x)],
        [(y + 1, x + 1), (y + 2, x + 2)]
    ]
    return neighbors, medium_points


def drawPath(img, path, thickness=3):
    '''path is a list of (x,y) tuples'''
    x0, y0 = path[0]
    for vertex in path[1:]:
        x1, y1 = vertex
        cv2.line(img, (y0, x0), (y1, x1), (225, 0, 0), thickness)
        x0, y0 = vertex


def paint_visited_pixels(image, pixel_array, color):
    for pixel_coords in pixel_array:
        y, x = pixel_coords
        image[y, x] = color
    return image


# start should look like this: [0, pos=(x,y), 'start']
_start = [0, start_point, 'start']
# end should be a tuple
_end = end_point  # maybe need to update
path, heap = dijkstra_path(binary_img, _start, _end)
# paint_visited_pixels(img, heap, (0,0,225)) # paint visited pixels
drawPath(img, path)

cv2.circle(img, start_point_circle, 3, (255, 0, 0), -1)  # add a circle at (5, 220)
cv2.circle(img, end_point_circle, 3, (0, 0, 255), -1)  # add a circle at (5,5)
plt.figure(figsize=(7, 7))
plt.imshow(img)  # show the image on the screen
plt.show()
end_time = time.time()  # Record the end time
elapsed_time = round(end_time - start_time, 1)  # Calculate the elapsed time
print(f"run time:{elapsed_time}")
